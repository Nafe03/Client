package dev.anarchy.waifuhax.client.systems.modules.exploits;

import dev.anarchy.waifuhax.api.WHLogger;
import dev.anarchy.waifuhax.api.settings.BooleanSetting;
import dev.anarchy.waifuhax.api.settings.EnumSetting;
import dev.anarchy.waifuhax.api.settings.IntegerSetting;
import dev.anarchy.waifuhax.api.systems.modules.AbstractModule;
import dev.anarchy.waifuhax.api.systems.modules.annotations.AutoDisable;
import dev.anarchy.waifuhax.api.util.InventoryUtils;
import dev.anarchy.waifuhax.client.events.TickEvent;
import meteordevelopment.orbit.EventHandler;
import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.Entity;
import net.minecraft.entity.decoration.ItemFrameEntity;
import net.minecraft.entity.player.PlayerInventory;
import net.minecraft.item.ItemStack;
import net.minecraft.item.Items;
import net.minecraft.network.packet.c2s.play.PlayerInteractEntityC2SPacket;
import net.minecraft.util.Hand;

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.concurrent.atomic.AtomicInteger;

enum DupeMode {
    NORMAL,
    RIGHT_CLICK_ONLY,
    ULTRA_STRICT
}

/**
 * @fixme : currently broken, might trigger the packet rate limit
 * @todo : burn this shit down.
 */
@AutoDisable
public class AutoFrameDupe extends AbstractModule {

    private final SimpleDateFormat sdf = new SimpleDateFormat("mm:ss:SSS");
    private final SimpleDateFormat second = new SimpleDateFormat("ss");
    public IntegerSetting maxFrame = new IntegerSetting("Max frames", "Max amount of frame hitten", 4, 0, 24);
    public IntegerSetting hitPerTick = new IntegerSetting("Delay", "Number of ticks to wait before hitting another item frame", 10, 1, 20);
    public BooleanSetting noDelay = new BooleanSetting("No delay", "attempt to dupe on every frame at once", false);
    public BooleanSetting speedrunMode = new BooleanSetting("Speedrun mode", "Screw it, we going competitive", false);
    public EnumSetting dupeMode = new EnumSetting("Dupe Mode", "Dupe Mode", DupeMode.NORMAL);
    int tick = 0, current = 0, refillTick = 0, hitFrame = 1, prevsecond = 0;
    int previousCount = 0, startedWith = 0;
    private ItemFrameEntity[] frames = new ItemFrameEntity[(int) maxFrame.getMax()];
    private boolean[] marked = new boolean[(int) maxFrame.getMax()];
    private long start = 0, end = 0;
    private int found_frame;
    private int _second = 0;
    private ItemStack holdItem;

    public AutoFrameDupe() {
        onToggle();
    }

    private void interact(ItemFrameEntity frame, int frameId) {

        if (frame == null || !frame.isAlive()) {return;}

        if (!marked[frameId]) {
            player.networkHandler.sendPacket(PlayerInteractEntityC2SPacket.interact(frame, false, Hand.MAIN_HAND));
            marked[frameId] = true;
        }
        else {
            if (!frames[frameId].getHeldItemStack().getItem().equals(Items.AIR)) {
                if (dupeMode.getValue() != DupeMode.RIGHT_CLICK_ONLY) {
                    player.networkHandler.sendPacket(PlayerInteractEntityC2SPacket.attack(frame, false));
                }
                hitFrame++;
            }
            marked[frameId] = false;
        }
    }

    @EventHandler
    public void onTick(TickEvent e) {

        if (hitPerTick.getValue() == 0) {hitPerTick.setValue(1);}

        refill();

        if (noDelay.getValue()) {
            AtomicInteger current = new AtomicInteger(0);
            Arrays.stream(frames).toList().forEach(frame -> {
                interact(frame, current.getAndIncrement());
            });
        }
        else if (tick >= (20 / hitPerTick.getValue())) {
            if (frames[current] == null) current = 0;
            interact(frames[current], current);
            current++;
            tick = 0;
        }

        if (speedrunMode.getValue() && player.getInventory().getEmptySlot() == -1) {
            isEnabled.setValue(false);
            onToggle();
            end = System.currentTimeMillis();
            WHLogger.printToChat("Duped a full inventory in " + sdf.format(end - start));
        }

        tick++;
    }

    /*
        @EventHandler
        public void onRenderScreen(RenderImGuiEvent event) {

            if (prevsecond != Integer.parseInt(second.format(System.currentTimeMillis() - start))) {
                _second++;
                prevsecond = Integer.parseInt(second.format(System.currentTimeMillis() - start));
            }

            if (_second == 0) {return;}

            if (ImGui.begin("AutoFrameDupe status")) {
                ImGui.text("Timer : " + sdf.format(System.currentTimeMillis() - start));
                ImGui.text("Estimated duped item : " + getCount());
                ImGui.text("Time based estimated item per second: " + (float) ((float) getCount() / (float) _second));
                ImGui.text("Estimated dupe chance: " + (float) ((float) getCount() / hitFrame) + "%");
                ImGui.text("Frame based estimated duped item per seconds: " + (float) (((float) getCount() / (float) hitFrame)) * (hitFrame / (_second == 0 ? 1 : _second)));
                ImGui.text("Frame hit total : " + hitFrame);
                ImGui.text("Frame hit per second : " + (hitFrame / (_second == 0 ? 1 : _second)));
            }
            ImGui.end();
        }
    */
    private int getCount() {
        if (previousCount < player.getInventory().count(holdItem.getItem()) - startedWith + found_frame) {
            previousCount = player.getInventory().count(holdItem.getItem()) - startedWith + found_frame;
        }
        return previousCount;
    }

    private void refill() {
        int newSlot = InventoryUtils.searchHotbar(itemStack -> holdItem.getItem().equals(itemStack.getItem()));
        if (PlayerInventory.isValidHotbarIndex(newSlot)) {
            InventoryUtils.selectSlot(newSlot);
        }
    }

    private void getNearbyItemFrames() {
        frames = new ItemFrameEntity[(int) maxFrame.getMax()];
        int i = 0;
        for (Entity e : MinecraftClient.getInstance().world.getEntities()) {
            if (e instanceof ItemFrameEntity && e.distanceTo(player) <= 4) {
                if (i < maxFrame.getValue()) {
                    frames[i] = (ItemFrameEntity) e;
                    marked[i] = false;
                    i++;
                }
            }

        }
        if (i == 0) {
            WHLogger.printToChat("Couldn't find item frames in range");
            onToggle(false);
        }
        else {WHLogger.printToChat(("Found " + i + " item frames"));}

        found_frame = i;
    }

    @Override
    public void onDeactivate(boolean live) {

        if (frames == null) {return;}

        frames = new ItemFrameEntity[(int) maxFrame.getMax()];
    }

    @Override
    public void onActivate(boolean live) {
        if (player == null) return;

        holdItem = player.getMainHandStack().getItem().getDefaultStack();
        startedWith = player.getInventory().count(holdItem.getItem());
        _second = 0;
        hitFrame = 1;
        previousCount = 0;
        start = System.currentTimeMillis();


        getNearbyItemFrames();
    }

    @Override
    public String getDescription() {
        return "Perform the frame dupe for you. Is the oldest piece of code of this client";
    }
}
